# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

default_platform(:ios)

platform :mac do
  desc "Import Developer ID certificates for macOS distribution"
  lane :certs do
    # Import Developer ID Application certificate
    match(
      type: "developer_id",
      platform: "macos",
      readonly: is_ci,
      skip_provisioning_profiles: true,
      skip_certificate_matching: true
    )
    
    # Import Developer ID Installer certificate
    match(
      type: "developer_id_installer",
      platform: "macos",
      readonly: is_ci,
      skip_provisioning_profiles: true,
      skip_certificate_matching: true
    )
  end

  desc "List available code signing identities"
  lane :list_identities do
    sh("echo '--- codesigning identities ---'")
    sh("security find-identity -v -p codesigning")
    sh("echo '--- basic identities (includes Installer) ---'")
    sh("security find-identity -v -p basic | grep -E 'Developer ID (Application|Installer):' || true")
  end

  desc "Build production-signed installer with code signing and notarization"
  lane :build_production do
    # Set up API key for notarization (CI vs local)
    if is_ci
      setup_ci
      api_key = app_store_connect_api_key(
        key_id: ENV['APPLE_APP_STORE_API_KEY_ID'],
        issuer_id: ENV['APPLE_APPSTORE_API_ISSUER_ID'],
        key_content: ENV['APPLE_APP_STORE_API_KEY']
      )
    else
      # Local development - use hardcoded credentials
      api_key = app_store_connect_api_key(
        key_id: "BZ9R9Y8474",
        issuer_id: "69a6de74-e8dd-47e3-e053-5b8c7c11a4d1",
        key_filepath: "/Users/justinkumpe/Documents/AuthKey_BZ9R9Y8474.p8",
        duration: 1200,
        in_house: false
      )
    end

    # Import Developer ID Application certificate
    # Note: Use readonly mode to avoid querying App Store Connect API for Developer ID certs
    match(
      type: "developer_id",
      platform: "macos",
      readonly: true,
      skip_provisioning_profiles: true,
      skip_certificate_matching: true
    )
    
    # Import Developer ID Installer certificate
    match(
      type: "developer_id_installer",
      platform: "macos",
      readonly: true,
      skip_provisioning_profiles: true,
      skip_certificate_matching: true
    )

    # Get signing identities from keychain
    # Prefer SHA-1 hashes to avoid ambiguity when multiple certs share the same name
    app_identity_hash = sh("security find-identity -v -p codesigning | grep 'Developer ID Application' | head -1 | awk '{print $2}'").strip
    app_identity_name = sh("security find-identity -v -p codesigning | grep 'Developer ID Application' | head -1 | sed -E 's/.*\"(.*)\".*/\\1/'").strip
    # Installer identities are not listed under the 'codesigning' policy. Use 'basic'.
    installer_identity_hash = sh("security find-identity -v -p basic | grep 'Developer ID Installer' | head -1 | awk '{print $2}'").strip
    installer_identity_name = sh("security find-identity -v -p basic | grep 'Developer ID Installer' | head -1 | sed -E 's/.*\"(.*)\".*/\\1/'").strip

    if app_identity_hash.empty?
      UI.user_error!("No 'Developer ID Application' certificate found")
    end
    if installer_identity_hash.empty?
      UI.message("Developer ID Installer cert not found in keychain; retrying readonly import...")
      match(
        type: "developer_id_installer",
        platform: "macos",
        readonly: true,
        skip_provisioning_profiles: true,
        skip_certificate_matching: false
      )
      installer_identity_hash = sh("security find-identity -v -p basic | grep 'Developer ID Installer' | head -1 | awk '{print $2}'").strip
      installer_identity_name = sh("security find-identity -v -p basic | grep 'Developer ID Installer' | head -1 | sed -E 's/.*\"(.*)\".*/\\1/'").strip
      if installer_identity_hash.empty?
        UI.user_error!("No 'Developer ID Installer' certificate found after import. Ensure your fastlane_certs repo contains a valid Developer ID Installer .p12 for team #{ENV['FASTLANE_TEAM_ID'] || 'your team'}.")
      end
    end

    UI.success("Found Application identity: #{app_identity_name} (#{app_identity_hash})")
    UI.success("Found Installer identity: #{installer_identity_name} (#{installer_identity_hash})")

    # Get version from environment or use default
    version = ENV['VERSION'] || '1.0.0'
    UI.message("Building version: #{version}")

    # Build uninstaller app
    UI.message("Building uninstaller app...")
    sh("bash ../create-uninstaller-app.sh")
    
    # Sign uninstaller app
    UI.message("Signing uninstaller app...")
    sh("xattr -cr '../Uninstall ManagedNebula.app' || true")
    sh(%Q(codesign --deep --force --verify --verbose --sign "#{app_identity_hash}" --options runtime --timestamp '../Uninstall ManagedNebula.app'))
    sh("codesign --verify --deep --strict --verbose=2 '../Uninstall ManagedNebula.app'")

    # Build unsigned installer (pass app identity so script can sign CLI binaries before packaging)
    UI.message("Building unsigned installer...")
    sh(%Q(VERSION="#{version}" APP_IDENTITY_HASH="#{app_identity_hash}" bash ../create-installer.sh))

    # Sign app bundle
    UI.message("Signing app bundle...")
    # Remove problematic extended attributes before signing
    sh("xattr -cr ../ManagedNebula.app || true")
    sh(%Q(codesign --deep --force --verify --verbose --sign "#{app_identity_hash}" --options runtime --timestamp ../ManagedNebula.app))
    sh("codesign --verify --deep --strict --verbose=2 ../ManagedNebula.app")

    # Sign PKG
    UI.message("Signing PKG...")
    sh(%Q(productsign --sign "#{installer_identity_hash}" ../dist/ManagedNebula-macos-#{version}.pkg ../dist/ManagedNebula-macos-#{version}-signed.pkg))
    sh("pkgutil --check-signature ../dist/ManagedNebula-macos-#{version}-signed.pkg")

    # Notarize PKG and staple
    UI.message("Notarizing PKG (and stapling)...")
    signed_pkg_path = File.expand_path("../dist/ManagedNebula-macos-#{version}-signed.pkg", __dir__)

    # Use notarytool directly to avoid Fastlane action issues
    if is_ci
      # CI: write key content to temporary file
      require 'tempfile'
      key_file = Tempfile.new(['AuthKey', '.p8'])
      begin
        key_file.write(api_key[:key])
        key_file.close
        sh(%Q(xcrun notarytool submit "#{signed_pkg_path}" --wait --key-id "#{api_key[:key_id]}" --issuer "#{api_key[:issuer_id]}" --key "#{key_file.path}"))
      ensure
        key_file.unlink
      end
    else
      # Local: use key file path
      sh(%Q(xcrun notarytool submit "#{signed_pkg_path}" --wait --key "/Users/justinkumpe/Documents/AuthKey_BZ9R9Y8474.p8" --key-id "BZ9R9Y8474" --issuer "69a6de74-e8dd-47e3-e053-5b8c7c11a4d1"))
    end
    sh(%Q(xcrun stapler staple "#{signed_pkg_path}"))

    # Create signed DMG
    UI.message("Creating signed DMG...")
    sh("rm -rf ../dist/dmg-contents-signed && mkdir -p ../dist/dmg-contents-signed")
    sh("cp -R ../ManagedNebula.app ../dist/dmg-contents-signed/")
    sh("ln -s /Applications ../dist/dmg-contents-signed/Applications")
    
    # Create README for DMG
    File.write("../dist/dmg-contents-signed/README.txt", <<~README)
      ManagedNebula Installation
      ==========================

      METHOD 1: Drag and Drop (Quick Install)
      ----------------------------------------
      1. Drag ManagedNebula.app to the Applications folder
      2. Open ManagedNebula from Applications
      3. Enter your server URL and client token

      NOTE: Requires Nebula binaries: brew install nebula

      METHOD 2: Use PKG Installer (Complete)
      ---------------------------------------
      Use the signed PKG for complete installation with LaunchDaemons.

      Troubleshooting
      ---------------
      - Logs: /var/log/nebula/nebula.log
      - Uninstall: sudo managednebula-uninstall [--purge]
      - Support: https://github.com/kumpeapps/managed-nebula
    README

    sh("hdiutil create -volname ManagedNebula -srcfolder ../dist/dmg-contents-signed -ov -format UDZO ../dist/ManagedNebula-macos-#{version}-signed.dmg")
    sh("rm -rf ../dist/dmg-contents-signed")

    UI.success("Production build complete!")
    UI.success("Signed PKG: dist/ManagedNebula-macos-#{version}-signed.pkg")
    UI.success("Signed DMG: dist/ManagedNebula-macos-#{version}-signed.dmg")
  end
end

platform :ios do
  desc "Updates match certificates"
  lane :update_match do
    if is_ci
      setup_ci
      api_key = app_store_connect_api_key(
        "key_id": ENV['APPLE_APP_STORE_API_KEY_ID'],
        "issuer_id": ENV['APPLE_APPSTORE_API_ISSUER_ID'],
        "key_content": ENV['APPLE_APP_STORE_API_KEY']
      )
    end
    if !is_ci
      api_key = app_store_connect_api_key(
        key_id: "BZ9R9Y8474",
        issuer_id: "69a6de74-e8dd-47e3-e053-5b8c7c11a4d1",
        key_filepath: "/Users/justinkumpe/Documents/AuthKey_BZ9R9Y8474.p8",
        duration: 1200, # optional (maximum 1200)
        in_house: false # optional but may be required if using match/sigh
    )
    end
    match(
      generate_apple_certs: true, 
      api_key: api_key,
      type: "adhoc"
    )
  end

  lane :matchget do
	if is_ci
		setup_ci
	end
  match(generate_apple_certs: true, type: "adhoc", readonly: is_ci, git_basic_authorization: ENV['MATCH_GIT_BASIC_AUTHORIZATION'], git_url: "https://github.com/kumpeapps/fastlane_certs.git")
  end
end
